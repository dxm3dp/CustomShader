# Unity 的阴影

2020.5.21(4)

为了让场景看起来更真实 , 具有深度信息 , 我们通常希望光源可以把一些物体的阴影投射在其他物体上 . 这个过程分为两部分 , 一是如何让一个物体向其他物体投射阴影 , 一是如何让一个物体接收来自其他物体的阴影 .

## 阴影的实现方式

让我们先来考虑一下真实生活中阴影是如何实现的 .

当一个光源发射的一条光线遇到一个不透明物体时 , 这条光线就无法再继续照亮其他物体 (这里不考虑光线反射) . 因此 , 这个物体就会向它旁边的物体投射阴影 . 那些阴影区域的产生是因为光线无法到达该区域 .

在实时渲染中 , 我们最长使用的是一种名为 **Shadow Map** 的技术 . 这种技术理解起来非常简单 , 它会首先把摄像机的位置放在与光源重合的位置上 , 那么场景中该光源的阴影区域就是那些摄像机看不到的地方 . Unity 就是用的这种技术 .

在前向渲染路径中 , 如果场景中最重要的平行光开启了阴影 , Unity 就会为该光源计算它的 shadowmap (阴影映射纹理) . 这张阴影映射纹理本质上也是一张深度图 , 它记录了从该光源的位置出发 , 能看到的场景中距离它最近的表面位置 (深度信息) .

那么 , 在计算 shadowmap 时 , 我们如何判定距离它最近的表面位置呢 ? 一种方法是 , 先把摄像机放置到光源的位置上 , 然后按照正常的渲染流程 , 即调用 **Base Pass** 和 **Additional Pass** 来更新深度信息 , 得到 shadowmap . 但这种方法会对性能造成一定的浪费 , 因为我们实际上只需要深度信息而已 , 而 **Base Pass** 和 **Additional Pass** 中往往涉及很多复杂的光照模型计算 . 因此 , Unity 选择使用一个额外的 Pass 来专门更新光源的shadowmap (阴影映射纹理) , 这个 Pass 就是 **LightMode** 标签被设置为 **ShadowCaster** 的 Pass . 这个 Pass 的渲染目标不是帧缓存 , 而是阴影映射纹理 (或深度纹理) .

Unity 首先把摄像机放置到光源的位置上 , 然后调用该 Pass , 通过对顶点变换后得到**光源空间**下的位置 , 并据此来输出深度信息到阴影映射纹理中 . 因此 , 当开启了光源的阴影效果后 , 底层渲染引擎首先会在当前渲染物体的 Unity Shader 中找到 **LightMode** 为 **ShadowCaster** 的 Pass . 如果没有 , 它就会在 **Fallback** 指定的 Unity Shader 中继续寻找 , 如果仍然没有找到 , 该物体就无法向其他物体投射阴影 (但它仍然可以接收来自其他物体的阴影) . 当找到了一个 **LightMode** 为 **ShaderCaster** 的 Pass 后 , Unity 会使用该 Pass 来更新光源的阴影映射纹理 .

在传统的阴影映射纹理的实现中 , 我们会在正常渲染的 Pass 中把顶点位置变换到光源空间下 , 以得到它在光源空间中的三维位置信息 . 然后 , 我们使用 xy 分量对阴影映射纹理进行采样 , 得到阴影映射纹理中该位置的深度信息 . 如果该深度值小于该顶点的深度值 (通常由 z 分量得到) , 那么说明该点位于阴影中 . 