# 凹凸映射

2020.3.24(2)

纹理的另一种常见的应用就是**凹凸映射 ( bump mapping )** . 凹凸映射的目的是使用一张纹理来修改模型的法线 , 以边为模型提供更多的细节 . 这种方法不会真的改变模型的顶点位置 , 只是让模型看起来好像是 "凹凸不平" 的 , 但可以从模型的轮廓处看出 "破绽" .

有两种主要的方法可以用来进行凹凸映射 : 一种方法是使用一张**高度纹理**来模拟表面位移 , 然后得到一个修改后的法线值 , 这种方法也被称为 **高度映射** ; 另一种方法则是使用一张**法线纹理**来直接存储表面法线 , 这种方法又被称为**法线映射** . 尽管我们常常将凹凸映射和法线映射当成是相同的技术 , 但我们需要知道它们之间的不同.

## 法线纹理

法线纹理中存储的就是表面的法线方向 . 由于法线方向的分量范围在 [ -1 , 1 ] , 而像素的分量范围在 [ 0 , 1 ] , 所以我们需要做一个映射 , 通常使用的映射就是 :

这就要求 , 我们在 shader 中对法线纹理进行纹理采样后 , 还需要对结果进行一次反映射的过程 , 以得到原先的法线方向 . 反映射的过程实际上就是使用上面映射函数的你函数 :

> normal = pixel \* 2 - 1

然而 , 由于方向是相对于坐标空间来说的 , 那么法线纹理中存储的法线方向位于哪个坐标空间中呢 ? 对于模型顶点自带的法线 , 它们是定义在模型空间中的 , 因此一种直接的想法就是将修改后的模型空间的表面法线存储在一张纹理中 , 这种纹理被称为**模型空间的法线纹理** . 然而 , 在实际制作中 , 我们往往会采用另一种坐标空间 , 即模型顶点的**切线空间**来存储法线 . 对于模型的每个顶点 , 它都有一个属于自己的切线空间 , 这个切线空间的原点就是该顶点本身 , 而 z 轴是顶点的法线方向 ( n ) , x 轴是顶点的切线方向 ( t ) , 而 y 轴 可由法线和切线叉积而得 , 也被称为副切线 ( bitangent , b ) . 这种纹理被称为是**切线空间的法线纹理** .

从视觉效果上来看 , 模型空间下的法线纹理看起来是"五颜六色"的 , 这是因为在模型空间中 , 每个顶点存储的法线方向是各异的 . 有的是 ( 0 , 1 , 0 ) , 经过映射后存储到纹理中就对应了 RGB ( 0.5 , 1 , 0.5 ) 浅绿色 , 有的是 ( 0 , -1 , 0 ) , 经过映射后存储到纹理中就对应了 ( 0.5 , 0 , 0.5 ) 紫色 . 而切线空间下的法线纹理看起来几乎全部都是浅蓝色的 , 这是因为每个法线方向所在的坐标空间是不一样的 , 即是表面每个顶点各自的切线空间 . 这种法线纹理其实就是存储了每个顶点在各自切线空间中的**法线扰动方向** . 也就是说 , 如果一个点的法线方向不变 , 那么在它的切线空间中 , 新的法线方向就是 z 轴方向 , 即值为 ( 0 , 0 , 1 ) , 经过映射后存储在纹理中就对应了 RGB ( 0.5 , 0.5 , 1 ) 浅蓝色 .

总体来说 , 模型空间下的法线纹理更符合人类的直观认识 , 而且法线纹理本身也很直观 , 容易调整 , 因为不同的法线方向就代表了不同的颜色 . 但美术人员往往更喜欢使用切线空间下的法线纹理 . 为什么他们更偏好使用这个看起来 "很蹩脚" 的切线空间呢 ?

实际上 , 法线本身存储在哪个坐标空间中都是可以的 , 我们甚至可以选择存储在世界空间下 . 但关键问题是 , 我们并不是单纯的想要得到法线 , 后续的光照计算才是我们的目的 . 而选择哪个坐标空间意味着我们需要把不同信息转换到相应的坐标系中 . 例如 , 如果选择了切线空间 , 我们需要把从法线纹理中得到的法线方向从切线空间转换到世界空间 ( 或其他空间 ) 中 .

总体来说 , 使用模型空间来存储法线的优点如下 :

- 实现简单 , 更加直观 . 我们甚至都不需要模型原始的法线和切线等信息 , 也就是说 , 计算更少 . 生成它也非常简单 , 而如果要生成切线空间下的法线纹理 , 由于模型的切线一般是和 UV 方向相同 , 因此想要得到效果比较好的法线映射就要求纹理映射也是连续的 .
- 在纹理坐标的缝合处和尖锐的边角部分 , 课件的突变 ( 缝隙 ) 较少 , 即可以提供平滑的边界 . 这是因为模型空间下的法线纹理存储的是同一坐标系下的法线信息 , 因此在边界处通过插值得到的法线可以平滑变换 . 而切线空间下的法线纹理中的法线信息是依靠纹理坐标的方向得到的结果 , 可能会在边缘处或尖锐的部分造成更过可见的缝合迹象 .

但使用切线空间有更多优点 :

- 自由度很高 . 模型空间下的法线纹理记录的是**绝对法线信息** , 仅可用于创建它时的那个模型 , 而应用到其他模型上效果就完全错误了 . 而切线空间下的法线纹理记录的是**相对发现信息** , 这意味着 , 即使把该纹理应用到一个完全不同的网格上 , 也可以得到一个合理的结果 .
- 可进行 UV 动画 . 比如 , 我们可以移动一个纹理的 UV 坐标来实现一个凹凸移动的效果 , 但使用模型空间下的法线纹理会得到完全错误的结果 . 这种 UV 动画在水或者火山熔岩这种类型的物体上会经常用到 .
- 可以重用法线纹理 . 比如 , 一个砖块 , 我们仅使用一张法线纹理就可以用到所有的 6 个面上 .
- 可压缩 . 由于切线空间下的法线纹理中法线的 Z 方向总是正方向 , 因此我们可以仅存储 XY 方向 , 而推导得到 Z 方向 . 而模型空间下的法线纹理由于每个方向都是可能的 , 因此必须存储 3 个方向的值 , 不可压缩 .

切线空间下的法线纹理的前两个优点足以让很多人放弃模型空间下的法线纹理而选择它 . 从上面的优点可以看出 , 切线空间在很多情况下都优于模型空间 , 而且可以节省美术人员的工作 . 因此 , 在本书中 , 我们使用的也是切线空间下的法线纹理 .

## 实践

我们需要在计算光照模型中统一各个方向矢量所在的坐标空间 . 由于法线纹理中存储的法线是切线空间下的方向 , 因此通常我们有两种选择 : 一种选择是在切线空间下进行光照计算 , 此时我们需要把光照方向 , 视角方向变换到切线空间下 ; 另一种选择是在世界空间下进行光照计算 , 此时我们需要把采样得到的法线方向变换到世界空间下 , 再和世界空间下的光照方向和视角方向进行计算 . 从效率上来说 , 第一种方法往往要优于第二种方法 , 因为我们可以在顶点着色器中就完成对光照方向和视角方向的变换 , 而第二种方法由于要先对法线纹理进行采样 , 所以变换过程必须在片元着色器中实现 , 这意味着我们需要在片元着色器中进行一次矩阵操作 . 但从通用性角度来说 , 第二种方法要优于第一种方法 , 因为有时我们需要在世界空间下进行一些计算 , 例如在使用 Cubemap 进行环境映射时 , 我们需要使用世界空间下的反射方向对 Cubemap 进行采样 . 如果同时需要进行法线映射 , 我们就需要把法线方向变换到世界空间下 .

### 在切线空间下计算光照

基本思路是 : 在片元着色器中通过纹理采样得到切线空间下的法线 , 然后再与切线空间下的视角方向 , 光照方向等进行计算 , 得到最终的光照结果 . 为此 , 我们需要先在顶点着色器中把视角方向和光照方向从模型空间变换到切线空间中 , 即我们需要知道从模型空间到切线空间的变换矩阵 . 这个变换矩阵的逆矩阵 , 即从切线空间到模型空间的变换矩阵是非常容易求得的 , 我们在顶点着色器中按切线 ( x 轴 ) 副切线 ( y 轴 ) 法线 ( z 轴 ) 的顺序**按列**排列即可得到 . 并且 , 如果一个变换中仅存在平移和旋转变换 , 那么这个变换的逆矩阵就等于它的转置矩阵 , 而从切线空间到模型空间的变换正是符合这样要求的变换 . 因此 , 从模型空间到切线空间的变换矩阵就是从切线空间到模型空间的变换矩阵的转置矩阵 , 我们把切线 ( x 轴 ) 副切线 ( y 轴 ) 法线 ( z 轴 ) 的顺序**按行**排列即可得到 .
